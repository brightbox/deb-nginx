= Name =

ngx_lua - Embed the power of Lua into Nginx

''This module is not distributed with the Nginx source.'' See [[#Installation|the installation instructions]].

= Status =

This module is under active development and is already production ready.

= Version =

This document describes ngx_lua [https://github.com/chaoslawful/lua-nginx-module/downloads v0.3.1rc8] released on 23 September 2011.

= Synopsis =
<geshi lang="nginx">
    # set search paths for pure Lua external libraries (';;' is the default path):
    lua_package_path '/foo/bar/?.lua;/blah/?.lua;;';
 
    # set search paths for Lua external libraries written in C (can also use ';;'):
    lua_package_cpath '/bar/baz/?.so;/blah/blah/?.so;;';
 
    server {
        location /inline_concat {
            # MIME type determined by default_type:
            default_type 'text/plain';
 
            set $a "hello";
            set $b "world";
            # inline lua script
            set_by_lua $res "return ngx.arg[1]..ngx.arg[2]" $a $b;
            echo $res;
        }
 
        location /rel_file_concat {
            set $a "foo";
            set $b "bar";
            # script path relative to nginx prefix
            # $ngx_prefix/conf/concat.lua contents:
            #
            #    return ngx.arg[1]..ngx.arg[2]
            #
            set_by_lua_file $res conf/concat.lua $a $b;
            echo $res;
        }
 
        location /abs_file_concat {
            set $a "fee";
            set $b "baz";
            # absolute script path not modified
            set_by_lua_file $res /usr/nginx/conf/concat.lua $a $b;
            echo $res;
        }
 
        location /lua_content {
            # MIME type determined by default_type:
            default_type 'text/plain';
 
            content_by_lua "ngx.say('Hello,world!')"
        }
 
         location /nginx_var {
            # MIME type determined by default_type:
            default_type 'text/plain';
 
            # try access /nginx_var?a=hello,world
            content_by_lua "ngx.print(ngx.var['arg_a'], '\\n')";
        }
 
        location /request_body {
             # force reading request body (default off)
             lua_need_request_body on;
             client_max_body_size 50k;
             client_body_buffer_size 50k;
 
             content_by_lua 'ngx.print(ngx.var.request_body)';
        }
 
        # transparent non-blocking I/O in Lua via subrequests
        location /lua {
            # MIME type determined by default_type:
            default_type 'text/plain';
 
            content_by_lua '
                local res = ngx.location.capture("/some_other_location")
                if res.status == 200 then
                    ngx.print(res.body)
                end';
        }
 
        # GET /recur?num=5
        location /recur {
            # MIME type determined by default_type:
            default_type 'text/plain';
 
            content_by_lua '
               local num = tonumber(ngx.var.arg_num) or 0
               ngx.say("num is: ", num)
 
               if num > 0 then
                   res = ngx.location.capture("/recur?num=" .. tostring(num - 1))
                   ngx.print("status=", res.status, " ")
                   ngx.print("body=", res.body)
               else
                   ngx.say("end")
               end
               ';
        }
 
        location /foo {
            rewrite_by_lua '
                res = ngx.location.capture("/memc",
                    { args = { cmd = 'incr', key = ngx.var.uri } }
                )
            ';
 
            proxy_pass http://blah.blah.com;
        }
 
        location /blah {
            access_by_lua '
                local res = ngx.location.capture("/auth")
 
                if res.status == ngx.HTTP_OK then
                    return
                end
 
                if res.status == ngx.HTTP_FORBIDDEN then
                    ngx.exit(res.status)
                end
 
                ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
            ';
 
            # proxy_pass/fastcgi_pass/postgres_pass/...
        }
 
        location /mixed {
            rewrite_by_lua_file /path/to/rewrite.lua;
            access_by_lua_file /path/to/access.lua;
            content_by_lua_file /path/to/content.lua;
        }
 
        # use nginx var in code path
        # WARN: contents in nginx var must be carefully filtered,
        # otherwise there'll be great security risk!
        location ~ ^/app/(.+) {
                content_by_lua_file /path/to/lua/app/root/$1.lua;
        }
 
        location / {
           lua_need_request_body on;
 
           client_max_body_size 100k;
           client_body_buffer_size 100k;
 
           access_by_lua '
               -- check the client IP addr is in our black list
               if ngx.var.remote_addr == "132.5.72.3" then
                   ngx.exit(ngx.HTTP_FORBIDDEN)
               end
 
               -- check if the request body contains bad words
               if ngx.var.request_body and
                        string.match(ngx.var.request_body, "fsck")
               then
                   return ngx.redirect("/terms_of_use.html")
               end
 
               -- tests passed
           ';
 
           # proxy_pass/fastcgi_pass/etc settings
        }
    }
</geshi>
= Description =

This module embeds the Lua interpreter or LuaJIT into the nginx core and integrates the powerful Lua threads (aka Lua coroutines) into the nginx event model
by means of nginx subrequests.

Unlike [http://httpd.apache.org/docs/2.3/mod/mod_lua.html Apache's mod_lua] and [http://redmine.lighttpd.net/wiki/1/Docs:ModMagnet Lighttpd's mod_magnet], Lua code written atop this module can be ''100% non-blocking'' on network traffic
as long as you use the [[#ngx.location.capture|ngx.location.capture]] or
[[#ngx.location.capture_multi|ngx.location.capture_multi]] interfaces
to let the nginx core do all your
requests to mysql, postgresql, memcached, redis,
upstream http web services, and etc etc etc (see
[[HttpDrizzleModule]], [http://github.com/FRiCKLE/ngx_postgres/ ngx_postgres], [[HttpMemcModule]], [[HttpRedis2Module]] and [[HttpProxyModule]] modules for details).

The Lua interpreter instance is shared across all
the requests in a single nginx worker process.

Request contexts are isolated from each other
by means of Lua (lightweight) threads (aka Lua coroutines).
And Lua modules loaded are persistent on
the nginx worker process level. So the memory
footprint is quite small even when your
nginx worker process is handling 10K requests at the same time.

= Directives =

== lua_code_cache ==
'''syntax:''' ''lua_code_cache on | off''

'''default:''' ''lua_code_cache on''

'''context:''' ''main, server, location, location if''

Enable or disable the Lua code cache for [[#set_by_lua_file|set_by_lua_file]],
[[#content_by_lua_file|content_by_lua_file]], [[#rewrite_by_lua_file|rewrite_by_lua_file]], and
[[#access_by_lua_file|access_by_lua_file]], and also force Lua module reloading on a per-request basis.

The Lua files referenced in [[#set_by_lua_file|set_by_lua_file]],
[[#content_by_lua_file|content_by_lua_file]], [[#access_by_lua_file|access_by_lua_file]],
and [[#rewrite_by_lua_file|rewrite_by_lua_file]] won't be cached at all,
and Lua's <code>package.loaded</code> table will be cleared
at every request's entry point (such that Lua modules
won't be cached either). So developers and enjoy
the PHP-way, i.e., edit-and-refresh.

But please note that Lua code inlined into nginx.conf
like those specified by [[#set_by_lua|set_by_lua]], [[#content_by_lua|content_by_lua]],
[[#access_by_lua|access_by_lua]], and [[#rewrite_by_lua|rewrite_by_lua]] will ''always'' be
cached because only nginx knows how to parse <code>nginx.conf</code>
and the only way to tell it to re-load the config file
is to send a <code>HUP</code> signal to it or just to restart it from scratch.

For now, ngx_lua does not support the "stat" mode like
Apache's <code>mod_lua</code>, but we will work on it in the future.

Disabling the Lua code cache is mainly used for Lua
development only because it has great
impact on the over-all performance and is strongly
discouraged for production uses. Also, race conditions
when reloading Lua modules are common for concurrent requests
when the code cache is off.

== lua_regex_cache_max_entries ==
'''syntax:''' ''lua_regex_cache_max_entries <num>''

'''default:''' ''lua_regex_cache_max_entries 1024''

'''context:''' ''http''

Specifies the maximal entries allowed in the worker-process-level compiled-regex cache.

The regular expressions used in [[#ngx.re.match|ngx.re.match]], [[#ngx.re.gmatch|ngx.re.gmatch]], [[#ngx.re.sub|ngx.re.sub]], and [[#ngx.re.gsub|ngx.re.gsub]] will be cached in this cache if the regex option <code>o</code> (i.e., compile-once flag) is specified.

The default entries allowed is 1024.

When the user Lua programs are exceeding this limit, those new regexes will not be cached at all (as if no <code>o</code> option is ever specified), and there will be one (and only one) warning in nginx's <code>error.log</code> file, like this
<geshi lang="text">
    2011/08/27 23:18:26 [warn] 31997#0: *1 lua exceeding regex cache max entries (1024), ...
</geshi>

You shouldn't specify the <code>o</code> regex option for regexes (and/or <code>replace</code> string arguments for [[#ngx.re.sub|ngx.re.sub]] and [[#ngx.re.gsub|ngx.re.gsub]]) that are generated ''on the fly'' and give rise to infinite variations, or you'll quickly reach the limit specified here.

== lua_package_path ==

'''syntax:''' ''lua_package_path <lua-style-path-str>''

'''default:''' ''The content of LUA_PATH environ variable or Lua's compiled-in defaults.''

'''context:''' ''main''

Set the Lua module searching path used by scripts specified by [[#set_by_lua|set_by_lua]],
[[#content_by_lua|content_by_lua]] and others. The path string is in standard Lua path form, and <code>;;</code>
can be used to stand for the original path.

== lua_package_cpath ==

'''syntax:''' ''lua_package_cpath <lua-style-cpath-str>''

'''default:''' ''The content of LUA_CPATH environ variable or Lua's compiled-in defaults.''

'''context:''' ''main''

Set the Lua C-module searching path used by scripts specified by [[#set_by_lua|set_by_lua]],
[[#content_by_lua|content_by_lua]] and others. The cpath string is in standard Lua cpath form, and <code>;;</code>
can be used to stand for the original cpath.

== set_by_lua ==

'''syntax:''' ''set_by_lua $res <lua-script-str> [$arg1 $arg2 ...]''

'''context:''' ''main, server, location, server if, location if''

'''phase:''' ''rewrite''

Execute user code specified by <code><lua-script-str></code> with input arguments <code>$arg1 $arg2 ...</code>, and set the script's return value to <code>$res</code> in string form. In
<code><lua-script-str></code> code the input arguments can be retrieved from <code>ngx.arg</code>
table (index starts from <code>1</code> and increased sequentially).

[[#set_by_lua|set_by_lua]] directives are designed to execute small and quick codes. Nginx
event loop is blocked during the code execution, so you'd better '''not''' call
anything that may be blocked or time-consuming.

Note that [[#set_by_lua|set_by_lua]] can only output a value to a single Nginx variable at
a time. But a work-around is also available by means of the [[#ngx.var.VARIABLE|ngx.var.VARIABLE]] interface,
for example,
<geshi lang="nginx">
    location /foo {
        set $diff ''; # we have to predefine the $diff variable here
 
        set_by_lua $sum '
            local a = 32
            local b = 56
 
            ngx.var.diff = a - b;  -- write to $diff directly
            return a + b;          -- return the $sum value normally
        ';
 
        echo "sum = $sum, diff = $diff";
    }
</geshi>

This directive can be freely mixed with all the directives of [[HttpRewriteModule]], [[HttpSetMiscModule]], and [[HttpArrayVarModule]]. All of these directives will run in exactly the same order that they are written in the config file. For example,
<geshi lang="nginx">
    set $foo 32;
    set_by_lua $bar 'tonumber(ngx.var.foo) + 1';
    set $baz "bar: $bar";  # $baz == "bar: 33"
</geshi>

This directive requires the [https://github.com/simpl/ngx_devel_kit ngx_devel_kit] module.

== set_by_lua_file ==

'''syntax:''' ''set_by_lua_file $res <path-to-lua-script> [$arg1 $arg2 ...]''

'''context:''' ''main, server, location, server if, location if''

Basically the same as [[#set_by_lua|set_by_lua]], except the code to be executed is in the
file specified by <code><path-lua-script></code>.

When the Lua code cache is on (this is the default), the user code is loaded
once at the first request and cached. Nginx config must be reloaded if you
modified the file and expected to see updated behavior. You can disable the
Lua code cache by setting <code>lua_code_cache off;</code> in your nginx.conf.

This directive requires the [https://github.com/simpl/ngx_devel_kit ngx_devel_kit] module.

== content_by_lua ==

'''syntax:''' ''content_by_lua <lua-script-str>''

'''context:''' ''location, location if''

'''phase:''' ''content''

Act as a content handler and execute user code specified by <code><lua-script-str></code>
for every request. The user code may call predefined APIs to generate response
content.

The use code is executed in a new spawned coroutine with independent global environment (i.e. a sandbox).

Do not use this directive and other content handler directives in a same location. For example, it's bad to use this directive with a [[HttpProxyModule#proxy_pass|proxy_pass]] directive in the same location.

== content_by_lua_file ==

'''syntax:''' ''content_by_lua_file <path-to-lua-script>''

'''context:''' ''location, location if''

'''phase:''' ''content''

Basically the same as [[#content_by_lua|content_by_lua]], except the code to be executed is in
the file specified by <code><path-lua-script></code>.

Nginx variables can be used in <code><path-to-lua-script></code> string, in order to provide
greater flexibility in practice. But this feature must be used carefully, so is
not recommend for beginners.

When the Lua code cache is on (this is the default), the user code is loaded once at the first request and cached. Nginx config must be reloaded if you modified the file and expected to see updated behavior. You can disable the Lua code cache by setting [[#lua_code_cache|lua_code_cache]] <code>off</code> in your <code>nginx.conf</code> file.

== rewrite_by_lua ==

'''syntax:''' ''rewrite_by_lua <lua-script-str>''

'''context:''' ''http, server, location, location if''

'''phase:''' ''rewrite tail''

Act as a rewrite phase handler and execute user code specified by <code><lua-script-str></code>
for every request. The user code may call predefined APIs to generate response
content.

This hook uses exactly the same mechamism as [[#content_by_lua|content_by_lua]] so all the nginx APIs defined there
are also available here.

Note that this handler always runs ''after'' the standard [[HttpRewriteModule]]. So the following will work as expected:

<geshi lang="nginx">
   location /foo {
       set $a 12; # create and initialize $a
       set $b ""; # create and initialize $b
       rewrite_by_lua 'ngx.var.b = tonumber(ngx.var.a) + 1';
       echo "res = $b";
   }
</geshi>

because <code>set $a 12</code> and <code>set $b ""</code> run ''before'' [[#rewrite_by_lua|rewrite_by_lua]].

On the other hand, the following will not work as expected:

<geshi lang="nginx">
    ?  location /foo {
    ?      set $a 12; # create and initialize $a
    ?      set $b ''; # create and initialize $b
    ?      rewrite_by_lua 'ngx.var.b = tonumber(ngx.var.a) + 1';
    ?      if ($b = '13') {
    ?         rewrite ^ /bar redirect;
    ?         break;
    ?      }
    ?
    ?      echo "res = $b";
    ?  }
</geshi>

because <code>if</code> runs ''before'' [[#rewrite_by_lua|rewrite_by_lua]] even if it's put after [[#rewrite_by_lua|rewrite_by_lua]] in the config.

The right way of doing this is as follows:

<geshi lang="nginx">
    location /foo {
        set $a 12; # create and initialize $a
        set $b ''; # create and initialize $b
        rewrite_by_lua '
            ngx.var.b = tonumber(ngx.var.a) + 1
            if ngx.var.b == 13 then
                return ngx.redirect("/bar");
            end
        ';
 
        echo "res = $b";
    }
</geshi>

It's worth mentioning that, the <code>ngx_eval</code> module can be approximately implemented by [[#rewrite_by_lua|rewrite_by_lua]]. For example,

<geshi lang="nginx">
    location / {
        eval $res {
            proxy_pass http://foo.com/check-spam;
        }
 
        if ($res = 'spam') {
            rewrite ^ /terms-of-use.html redirect;
        }
 
        fastcgi_pass ...;
    }
</geshi>

can be implemented in terms of <code>ngx_lua</code> like this

<geshi lang="nginx">
    location = /check-spam {
        internal;
        proxy_pass http://foo.com/check-spam;
    }
 
    location / {
        rewrite_by_lua '
            local res = ngx.location.capture("/check-spam")
            if res.body == "spam" then
                ngx.redirect("/terms-of-use.html")
            end
        ';
 
        fastcgi_pass ...;
    }
</geshi>

Just as any other rewrite phase handlers, [[#rewrite_by_lua|rewrite_by_lua]] also runs in subrequests.

Note that calling <code>ngx.exit(ngx.OK)</code> just returning from the current [[#rewrite_by_lua|rewrite_by_lua]] handler, and the nginx request processing control flow will still continue to the content handler. To terminate the current request from within the current [[#rewrite_by_lua|rewrite_by_lua]] handler, calling [[#ngx.exit|ngx.exit]] with status >= 200 (<code>ngx.HTTP_OK</code>) and status < 300 (<code>ngx.HTTP_SPECIAL_RESPONSE</code>) for successful quits and <code>ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)</code> (or its friends) for failures.

== rewrite_by_lua_file ==

'''syntax:''' ''rewrite_by_lua_file <path-to-lua-script>''

'''context:''' ''http, server, location, location if''

'''phase:''' ''rewrite tail''

Same as [[#rewrite_by_lua|rewrite_by_lua]], except the code to be executed is in
the file specified by <code><path-lua-script></code>.

Nginx variables can be used in <code><path-to-lua-script></code> string, in order to provide
greater flexibility in practice. But this feature must be used carefully, so is
not recommend for beginners.

When the Lua code cache is on (this is the default), the user code is loaded
once at the first request and cached. Nginx config must be reloaded if you
modified the file and expected to see updated behavior. You can disable the
Lua code cache by setting [[#lua_code_cache|lua_code_cache]] <code>off</code> in your <code>nginx.conf</code> file.

== access_by_lua ==

'''syntax:''' ''access_by_lua <lua-script-str>''

'''context:''' ''http, server, location, location if''

'''phase:''' ''access tail''

Act as an access phase handler and execute user code specified by <code><lua-script-str></code> for every request. The user code may call predefined APIs to generate response content.

This hook uses exactly the same mechanism as [[#content_by_lua|content_by_lua]] so all the nginx APIs defined there are also available here.

Note that this handler always runs ''after'' the standard [[HttpAccessModule]]. So the following will work as expected:

<geshi lang="nginx">
    location / {
        deny    192.168.1.1;
        allow   192.168.1.0/24;
        allow   10.1.1.0/16;
        deny    all;
 
        access_by_lua '
            local res = ngx.location.capture("/mysql", { ... })
            ...
        ';
 
        # proxy_pass/fastcgi_pass/...
    }
</geshi>

That is, if a client address appears in the blacklist, then we don't have to bother sending a MySQL query to do more advanced authentication in [[#access_by_lua|access_by_lua]].

It's worth mentioning that, the <code>ngx_auth_request</code> module can be approximately implemented by [[#access_by_lua|access_by_lua]]. For example,

<geshi lang="nginx">
    location / {
        auth_request /auth;
 
        # proxy_pass/fastcgi_pass/postgres_pass/...
    }
</geshi>

can be implemented in terms of <code>ngx_lua</code> like this

<geshi lang="nginx">
    location / {
        access_by_lua '
            local res = ngx.location.capture("/auth")
 
            if res.status == ngx.HTTP_OK then
                return
            end
 
            if res.status == ngx.HTTP_FORBIDDEN then
                ngx.exit(res.status)
            end
 
            ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)
        ';
 
        # proxy_pass/fastcgi_pass/postgres_pass/...
    }
</geshi>

Just as any other access phase handlers, [[#access_by_lua|access_by_lua]] will ''not'' run in subrequests.

Note that calling <code>ngx.exit(ngx.OK)</code> just returning from the current [[#access_by_lua|access_by_lua]] handler, and the nginx request processing control flow will still continue to the content handler. To terminate the current request from within the current [[#access_by_lua|access_by_lua]] handler, calling <code>ngx.exit(status)</code> where status >= 200 (<code>ngx.HTTP_OK</code>) and status < 300 (<code>ngx.HTTP_SPECIAL_RESPONSE</code>) for successful quits and <code>ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)</code> or its friends for failures.

== access_by_lua_file ==

'''syntax:''' ''access_by_lua_file <path-to-lua-script>''

'''context:''' ''http, server, location, location if''

'''phase:''' ''access tail''

Same as [[#access_by_lua|access_by_lua]], except the code to be executed is in the file
specified by <code><path-lua-script></code>.

Nginx variables can be used in <code><path-to-lua-script></code> string, in order to provide
greater flexibility in practice. But this feature must be used carefully, so is
not recommend for beginners.

When the Lua code cache is on (this is the default), the user code is loaded
once at the first request and cached. Nginx config must be reloaded if you
modified the file and expected to see updated behavior. You can disable the
Lua code cache by setting [[#lua_code_cache|lua_code_cache]] <code>off</code> in your <code>nginx.conf</code> file.

== header_filter_by_lua ==

'''syntax:''' ''header_filter_by_lua <lua-script-str>''

'''context:''' ''http, server, location, location if''

'''phase:''' ''output header filter''

Use Lua defined in <code><lua-script-str></code> to define an output header filter. For now, the following Nginx Lua APIs are disabled in this context:

* Output API (e.g., [[#ngx.say|ngx.say]] and [[#ngx.send_headers|ngx.send_headers]])
* Control APIs (e.g., [[#ngx.exit|ngx.exit]]) 
* Subrequest APIs (e.g., [[#ngx.location.capture|ngx.location.capture]] and [[#ngx.location.capture_multi|ngx.location.capture_multi]])

Here's a small example of overriding a response header (or adding if it does not exist) in our Lua header filter:
<geshi lang="nginx">
    location / {
        proxy_pass http://mybackend;
        header_filter_by_lua 'ngx.header.Foo = "blah"';
    }
</geshi>

This directive was first introduced in the <code>v0.2.1rc20</code> release.

== header_filter_by_lua_file ==

'''syntax:''' ''header_filter_by_lua_file <path-to-lua-script-file>''

'''context:''' ''http, server, location, location if''

'''phase:''' ''output header filter''

Use Lua code defined in a separate file specified by <code><path-to-lua-script-file></code> to define an output header filter.

This is very much like [[#header_filter_by_lua|header_filter_by_lua]] except that it loads Lua code from an external Lua source file.

This directive was first introduced in the <code>v0.2.1rc20</code> release.

== lua_need_request_body ==

'''syntax:''' ''lua_need_request_body <on | off>''

'''default:''' ''off''

'''context:''' ''main | server | location''

'''phase:''' ''depends on usage''

Force reading request body data or not. The client request body won't be read, so you have to explicitly force reading the body if you need its content.

If you want to read the request body data from the [[HttpCoreModule#$request_body|$request_body]] variable, make sure that
your have configured [[HttpCoreModule#client_body_buffer_size|client_body_buffer_size]] to have exactly the same value as [[HttpCoreModule#client_max_body_size|client_max_body_size]].

If the current location defines [[#rewrite_by_lua|rewrite_by_lua]] or [[#rewrite_by_lua_file|rewrite_by_lua_file]],
then the request body will be read just before the [[#rewrite_by_lua|rewrite_by_lua]] or [[#rewrite_by_lua_file|rewrite_by_lua_file]] code is run (and also at the
<code>rewrite</code> phase). Similarly, if only [[#content_by_lua|content_by_lua]] is specified,
the request body won't be read until the content handler's Lua code is
about to run (i.e., the request body will be read at the
content phase).

The same applies to [[#access_by_lua|access_by_lua]] and [[#access_by_lua_file|access_by_lua_file]].

= Nginx API for Lua =

The Nginx API exposed to the Lua land is provided in the form of two standard packages <code>ngx</code> and <code>ndk</code>. These packages are in the default global scope.

When you're writing your own external Lua modules, however, you can introduce these packages by using the [http://www.lua.org/manual/5.1/manual.html#pdf-package.seeall package.seeall] option:

<geshi lang="lua">
    module("my_module", package.seeall)

    function say(a) ngx.say(a) end
</geshi>

Alternatively, import them to your Lua modules by using file-scoped local Lua variables, like this:

<geshi lang="lua">
    local ngx = ngx
    module("my_module")

    function say(a) ngx.say(a) end
</geshi>

You can directly require the standard packages <code>ngx</code> and <code>ndk</code> introduced by this Nginx module, like this:

<geshi lang="lua">
    local ngx = require "ngx"
    local ndk = require "ndk"
</geshi>

The ability to require these packages was introduced in the <code>v0.2.1rc19</code> release.

Network I/O operations in user code should only be done through our Nginx APIs defined below, otherwise Nginx event loop may be blocked and performance may drop off dramatically. Small disk file operations can be done via Lua's standard <code>io</code> and <code>file</code> libraries but should be eliminated wherever possible because these also block the Nginx process. Delegating all network and disk I/O operations to Nginx subrequests (via the [[#ngx.location.catpure|ngx.location.capture]] method and its friends) are strongly recommended.

== ngx.arg ==
'''syntax:''' ''val = ngx.arg[index]''

'''context:''' ''set_by_lua*''

Index the input arguments to the [[#set_by_lua|set_by_lua]] and [[#set_by_lua_file|set_by_lua_file]] directives:

<geshi lang="lua">
    value = ngx.arg[n]
</geshi>

Here's an example

<geshi lang="nginx">
    location /foo {
        set $a 32;
        set $b 56;
 
        set_by_lua $res
            'return tonumber(ngx.arg[1]) + tonumber(ngx.arg[2])'
            $a $b;
 
        echo $sum;
    }
</geshi>

that outputs <code>88</code>, the sum of <code>32</code> and <code>56</code>.

== ngx.var.VARIABLE ==
'''syntax:''' ''ngx.var.VAR_NAME''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''
<geshi lang="nginx">
    value = ngx.var.some_nginx_variable_name
    ngx.var.some_nginx_variable_name = value
</geshi>
Note that you can only write to nginx variables that are already defined.
For example:
<geshi lang="nginx">
    location /foo {
        set $my_var ''; # this line is required to create $my_var at config time
        content_by_lua '
            ngx.var.my_var = 123;
            ...
        ';
    }
</geshi>
That is, nginx variables cannot be created on-the-fly.

Some special nginx variables like <code>$args</code> and <code>$limit_rate</code> can be assigned a value,
some are not, like <code>$arg_PARAMETER</code>.

Nginx regex group capturing variables <code>$1</code>, <code>$2</code>, <code>$3</code>, and etc, can be read by this
interface as well, by writing <code>ngx.var[1]</code>, <code>ngx.var[2]</code>, <code>ngx.var[3]</code>, and etc.

== Core constants ==
'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

<geshi lang="lua">
  ngx.OK (0)
  ngx.ERROR (-1)
  ngx.AGAIN (-2)
  ngx.DONE (-4)
</geshi>
They take the same values of <code>NGX_OK</code>, <code>NGX_AGAIN</code>, <code>NGX_DONE</code>, <code>NGX_ERROR</code>, and etc. But now
only [[#ngx.exit|ngx.exit]] only take two of these values, i.e., <code>NGX_OK</code> and <code>NGX_ERROR</code>.

== HTTP method constants ==
'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

<geshi lang="lua">
  ngx.HTTP_GET
  ngx.HTTP_HEAD
  ngx.HTTP_PUT
  ngx.HTTP_POST
  ngx.HTTP_DELETE
</geshi>

These constants are usually used in [[#ngx.location.capture|ngx.location.catpure]] and [[#ngx.location.capture_multi|ngx.location.capture_multi]] method calls.

== HTTP status constants ==
'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''
<geshi lang="nginx">
  value = ngx.HTTP_OK (200)
  value = ngx.HTTP_CREATED (201)
  value = ngx.HTTP_SPECIAL_RESPONSE (300)
  value = ngx.HTTP_MOVED_PERMANENTLY (301)
  value = ngx.HTTP_MOVED_TEMPORARILY (302)
  value = ngx.HTTP_SEE_OTHER (303)
  value = ngx.HTTP_NOT_MODIFIED (304)
  value = ngx.HTTP_BAD_REQUEST (400)
  value = ngx.HTTP_UNAUTHORIZED (401)
  value = ngx.HTTP_FORBIDDEN (403)
  value = ngx.HTTP_NOT_FOUND (404)
  value = ngx.HTTP_NOT_ALLOWED (405)
  value = ngx.HTTP_GONE (410)
  value = ngx.HTTP_INTERNAL_SERVER_ERROR (500)
  value = ngx.HTTP_SERVICE_UNAVAILABLE (503)
</geshi>

== Nginx log level constants ==
'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''
<geshi lang="lua">
  ngx.STDERR
  ngx.EMERG
  ngx.ALERT
  ngx.CRIT
  ngx.ERR
  ngx.WARN
  ngx.NOTICE
  ngx.INFO
  ngx.DEBUG
</geshi>

These constants are usually used by the [[#ngx.log|ngx.log]] method.

== print ==
'''syntax:''' ''print(...)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Emit args concatenated to nginx's <code>error.log</code> file, with log level <code>ngx.NOTICE</code> and prefix <code>lua print: </code>.

It's equivalent to
<geshi lang="lua">
    ngx.log(ngx.NOTICE, 'lua print: ', a, b, ...)
</geshi>
Lua <code>nil</code> arguments are accepted and result in literal <code>"nil"</code>, and Lua booleans result in <code>"true"</code> or <code>"false"</code>.

== ngx.ctx ==
'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

This table can be used to store per-request context data for Lua programmers.

This table has a liftime identical to the current request (just like Nginx variables). Consider the following example,
<geshi lang="nginx">
    location /test {
        rewrite_by_lua '
            ngx.say("foo = ", ngx.ctx.foo)
            ngx.ctx.foo = 76
        ';
        access_by_lua '
            ngx.ctx.foo = ngx.ctx.foo + 3
        ';
        content_by_lua '
            ngx.say(ngx.ctx.foo)
        ';
    }
</geshi>
Then <code>GET /test</code> will yield the output
<geshi lang="bash">
    foo = nil
    79
</geshi>
That is, the <code>ngx.ctx.foo</code> entry persists across the rewrite, access, and content phases of a request.

Also, every request has its own copy, include subrequests, for example:
<geshi lang="nginx">
    location /sub {
        content_by_lua '
            ngx.say("sub pre: ", ngx.ctx.blah)
            ngx.ctx.blah = 32
            ngx.say("sub post: ", ngx.ctx.blah)
        ';
    }
 
    location /main {
        content_by_lua '
            ngx.ctx.blah = 73
            ngx.say("main pre: ", ngx.ctx.blah)
            local res = ngx.location.capture("/sub")
            ngx.print(res.body)
            ngx.say("main post: ", ngx.ctx.blah)
        ';
    }
</geshi>
Then <code>GET /main</code> will give the output
<geshi lang="bash">
    main pre: 73
    sub pre: nil
    sub post: 32
    main post: 73
</geshi>
We can see that modification of the <code>ngx.ctx.blah</code> entry in the subrequest does not affect the one in its parent request. They do have two separate versions of <code>ngx.ctx.blah</code> per se.

Internal redirection will destroy the original request's <code>ngx.ctx</code> data (if any) and the new request will have an emptied <code>ngx.ctx</code> table. For instance,
<geshi lang="nginx">
    location /new {
        content_by_lua '
            ngx.say(ngx.ctx.foo)
        ';
    }
 
    location /orig {
        content_by_lua '
            ngx.ctx.foo = "hello"
            ngx.exec("/new")
        ';
    }
</geshi>
Then <code>GET /orig</code> will give you
<geshi lang="bash">
    nil
</geshi>
rather than the original <code>"hello"</code> value.

Arbitrary data values can be inserted into this "matic" table, including Lua closures and nested tables. You can also register your own meta methods with it.

Overriding <code>ngx.ctx</code> with a new Lua table is also supported, for example,
<geshi lang="lua">
    ngx.ctx = { foo = 32, bar = 54 }
</geshi>

== ngx.location.capture ==
'''syntax:''' ''res = ngx.location.capture(uri, options?)''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Issue a synchronous but still non-blocking ''Nginx Subrequest'' using <code>uri</code>.

Nginx subrequests provide a powerful way to make non-blocking internal requests to other locations configured with disk file directory or ''any'' other nginx C modules like <code>ngx_proxy</code>, <code>ngx_fastcgi</code>, <code>ngx_memc</code>,
<code>ngx_postgres</code>, <code>ngx_drizzle</code>, and even <code>ngx_lua</code> itself and etc etc etc.

Also note that subrequests just mimic the HTTP interface but there's ''no'' extra HTTP/TCP traffic ''nor'' IPC involved. Everything works internally, efficiently, on the C level.

Subrequests are completely different from HTTP 301/302 redirection (via [[#ngx.redirect|ngx.redirect]]) and internal redirection (via [[#ngx.exec|ngx.exec]]).

Here's a basic example:
<geshi lang="lua">
    res = ngx.location.capture(uri)
</geshi>
Returns a Lua table with three slots (<code>res.status</code>, <code>res.header</code>, and <code>res.body</code>).

<code>res.header</code> holds all the response headers of the
subrequest and it is a normal Lua table. For multi-value response headers,
the value is a Lua (array) table that holds all the values in the order that
they appear. For instance, if the subrequest response headers contains the following
lines:
<geshi lang="bash">
    Set-Cookie: a=3
    Set-Cookie: foo=bar
    Set-Cookie: baz=blah
</geshi>
Then <code>res.header["Set-Cookie"]</code> will be evaluted to the table value
<code>{"a=3", "foo=bar", "baz=blah"}</code>.

URI query strings can be concatenated to URI itself, for instance,
<geshi lang="lua">
    res = ngx.location.capture('/foo/bar?a=3&b=4')
</geshi>
Named locations like <code>@foo</code> are not allowed due to a limitation in
the nginx core. Use normal locations combined with the <code>internal</code> directive to
prepare internal-only locations.

An optional option table can be fed as the second
argument, which support various options like
<code>method</code>, <code>body</code>, <code>args</code>, and <code>share_all_vars</code>.
Issuing a POST subrequest, for example,
can be done as follows
<geshi lang="lua">
    res = ngx.location.capture(
        '/foo/bar',
        { method = ngx.HTTP_POST, body = 'hello, world' }
    )
</geshi>
See HTTP method constants methods other than POST.
The <code>method</code> option is <code>ngx.HTTP_GET</code> by default.

The <code>share_all_vars</code> option can control whether to share nginx variables
among the current request and the new subrequest. If this option is set to <code>true</code>, then
the subrequest can see all the variable values of the current request while the current
requeset can also see any variable value changes made by the subrequest.
Note that variable sharing can have unexpected side-effects
and lead to confusing issues, use it with special
care. So, by default, the option is set to <code>false</code>.

The <code>args</code> option can specify extra url arguments, for instance,
<geshi lang="lua">
    ngx.location.capture('/foo?a=1',
        { args = { b = 3, c = ':' } }
    )
</geshi>
is equivalent to
<geshi lang="lua">
    ngx.location.capture('/foo?a=1&b=3&c=%3a')
</geshi>
that is, this method will automatically escape argument keys and values according to URI rules and
concatenating them together into a complete query string. Because it's all done in hand-written C,
it should be faster than your own Lua code.

The <code>args</code> option can also take plain query string:
<geshi lang="lua">
    ngx.location.capture('/foo?a=1',
        { args = 'b=3&c=%3a' } }
    )
</geshi>
This is functionally identical to the previous examples.

Note that, by default, subrequests issued by [[#ngx.location.capture|ngx.location.capture]] inherit all the
request headers of the current request. This may have unexpected side-effects on the
subrequest responses. For example, when you're using the standard <code>ngx_proxy</code> module to serve
your subrequests, then an "Accept-Encoding: gzip" header in your main request may result
in gzip'd responses that your Lua code is not able to handle properly. So always set
[[HttpProxyModule#proxy_pass_request_headers|proxy_pass_request_headers]] <code>off</code> in your subrequest location to ignore the original request headers.

== ngx.location.capture_multi ==
'''syntax:''' ''res1, res2, ... = ngx.location.capture_multi({ {uri, options?}, {uri, options?}, ... })''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Just like [[#ngx.location.capture|ngx.location.capture]], but supports multiple subrequests running in parallel.

This function issue several parallel subrequests specified by the input table, and returns their results in the same order. For example,
<geshi lang="lua">
    res1, res2, res3 = ngx.location.capture_multi{
        { "/foo", { args = "a=3&b=4" } },
        { "/bar" },
        { "/baz", { method = ngx.HTTP_POST, body = "hello" } },
    }
 
    if res1.status == ngx.HTTP_OK then
        ...
    end
 
    if res2.body == "BLAH" then
        ...
    end
</geshi>
This function will not return until all the subrequests terminate.
The total latency is the longest latency of the subrequests, instead of their sum.

When you don't know inadvance how many subrequests you want to issue,
you can use Lua tables for both requests and responses. For instance,
<geshi lang="lua">
    -- construct the requests table
    local reqs = {}
    table.insert(reqs, { "/mysql" })
    table.insert(reqs, { "/postgres" })
    table.insert(reqs, { "/redis" })
    table.insert(reqs, { "/memcached" })
 
    -- issue all the requests at once and wait until they all return
    local resps = { ngx.location.capture_multi(reqs) }
 
    -- loop over the responses table
    for i, resp in ipairs(resps) do
        -- process the response table "resp"
    end
</geshi>
The [[#ngx.location.capture|ngx.location.capture]] function is just a special form
of this function. Logically speaking, the [[#ngx.location.capture|ngx.location.capture]] can be implemented like this
<geshi lang="lua">
    ngx.location.capture =
        function (uri, args)
            return ngx.location.capture_multi({ {uri, args} })
        end
</geshi>

== ngx.status ==
'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Read and write the current request's response status. This should be called
before sending out the response headers.
<geshi lang="lua">
    ngx.status = ngx.HTTP_CREATED
    status = ngx.status
</geshi>

== ngx.header.HEADER ==
'''syntax:''' ''ngx.header.HEADER = VALUE''

'''syntax:''' ''value = ngx.header.HEADER''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

When assigning to <code>ngx.header.HEADER</code> will set, add, or clear the current request's response header named <code>HEADER</code>. Underscores (<code>_</code>) in the header names will be replaced by dashes (<code>-</code>) and the header names will be matched case-insensitively.

<geshi lang="lua">
    -- equivalent to ngx.header["Content-Type"] = 'text/plain'
    ngx.header.content_type = 'text/plain';
 
    ngx.header["X-My-Header"] = 'blah blah';
</geshi>

Multi-value headers can be set this way:

<geshi lang="lua">
    ngx.header['Set-Cookie'] = {'a=32; path=/', 'b=4; path=/'}
</geshi>

will yield

<geshi lang="bash">
    Set-Cookie: a=32; path=/
    Set-Cookie: b=4; path=/
</geshi>

in the response headers. Only array-like tables are accepted.

Note that, for those standard headers that only accepts a single value, like <code>Content-Type</code>, only the last element
in the (array) table will take effect. So

<geshi lang="lua">
    ngx.header.content_type = {'a', 'b'}
</geshi>

is equivalent to

<geshi lang="lua">
    ngx.header.content_type = 'b'
</geshi>

Setting a slot to <code>nil</code> effectively removes it from the response headers:

<geshi lang="lua">
    ngx.header["X-My-Header"] = nil;
</geshi>

same does assigning an empty table:

<geshi lang="lua">
    ngx.header["X-My-Header"] = {};
</geshi>

Setting <code>ngx.header.HEADER</code> after sending out response headers (either explicitly with [[#ngx.send_headers|ngx.send_headers]] or implicitly with [[#ngx.print|ngx.print]] and its friends) will throw out a Lua exception.

Reading <code>ngx.header.HEADER</code> will return the value of the response header named <code>HEADER</code>. Underscores (<code>_</code>) in the header names will also be replaced by dashes (<code>-</code>) and the header names will be matched case-insensitively. If the response header is not present at all, <code>nil</code> will be returned.

This is particularly useful in the context of [[#filter_header_by_lua|filter_header_by_lua]] and [[#filter_header_by_lua_file|filter_header_by_lua_file]], for example,

<geshi lang="nginx">
    location /test {
        set $footer '';

        proxy_pass http://some-backend;

        header_filter_by_lua '
            if ngx.header["X-My-Header"] == "blah" then
                ngx.var.footer = "some value"
            end
        ';

        echo_after_body $footer;
    }
</geshi>

For multi-value headers, all of the values of header will be collected in order and returned as a Lua table. For example, response headers

<geshi lang="text">
    Foo: bar
    Foo: baz
</geshi>

will result in

<geshi lang="lua">
    {"bar", "baz"}
</geshi>

to be returned when reading <code>ngx.header.Foo</code>.

Note that <code>ngx.header</code> is not a normal Lua table so you cannot iterate through it using Lua's <code>ipairs</code> function.

For reading ''request'' headers, use the [[#ngx.req.get_headers|ngx.req.get_headers]] function instead.

== ngx.req.get_uri_args ==
'''syntax:''' ''args = ngx.req.get_uri_args()''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Returns a Lua table holds all of the current request's request URL query arguments.

Here's an example,
<geshi lang="nginx">
    location = /test {
        content_by_lua '
            local args = ngx.req.get_uri_args()
            for key, val in pairs(args) do
                if type(val) == "table" then
                    ngx.say(key, ": ", table.concat(val, ", "))
                else
                    ngx.say(key, ": ", val)
                end
            end
        ';
    }
</geshi>
Then <code>GET /test?foo=bar&bar=baz&bar=blah</code> will yield the response body
<geshi lang="bash">
    foo: bar
    bar: baz, blah
</geshi>
Multiple occurrences of an argument key will result in a table value holding all of the values for that key in order.

Keys and values will be automatically unescaped according to URI escaping rules. For example, in the above settings, <code>GET /test?a%20b=1%61+2</code> will yield the output
<geshi lang="bash">
    a b: 1a 2
</geshi>
Arguments without the <code>=<value></code> parts are treated as boolean arguments. For example, <code>GET /test?foo&bar</code> will yield the outputs
<geshi lang="bash">
    foo: true
    bar: true
</geshi>
That is, they will take Lua boolean values <code>true</code>. However, they're different from arguments taking empty string values. For example, <code>GET /test?foo=&bar=</code> will give something like
<geshi lang="bash">
    foo: 
    bar: 
</geshi>
Empty key arguments are discarded, for instance, <code>GET /test?=hello&=world</code> will yield empty outputs.

Updating query arguments via the nginx variable <code>$args</code> (or <code>ngx.var.args</code> in Lua) at runtime are also supported:
<geshi lang="lua">
    ngx.var.args = "a=3&b=42"
    local args = ngx.req.get_uri_args()
</geshi>
Here the <code>args</code> table will always look like
<geshi lang="lua">
    {a = 3, b = 42}
</geshi>
regardless of the actual request query string.

== ngx.req.get_post_args ==
'''syntax:''' ''ngx.req.get_post_args()''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Returns a Lua table holds all of the current request's POST query arguments. It's required to turn on the [[#lua_need_request_body|lua_need_request_body]] directive, or a Lua exception will be thrown.

Here's an example,
<geshi lang="nginx">
    location = /test {
        lua_need_request_body on;
        content_by_lua '
            local args = ngx.req.get_post_args()
            for key, val in pairs(args) do
                if type(val) == "table" then
                    ngx.say(key, ": ", table.concat(val, ", "))
                else
                    ngx.say(key, ": ", val)
                end
            end
        ';
    }
</geshi>
Then
<geshi lang="bash">
    # Post request with the body 'foo=bar&bar=baz&bar=blah'
    $ curl --data 'foo=bar&bar=baz&bar=blah' localhost/test
</geshi>
will yield the response body like
<geshi lang="bash">
    foo: bar
    bar: baz, blah
</geshi>
Multiple occurrences of an argument key will result in a table value holding all of the values for that key in order.

Keys and values will be automatically unescaped according to URI escaping rules. For example, in the above settings,
<geshi lang="bash">
    # POST request with body 'a%20b=1%61+2'
    $ curl -d 'a%20b=1%61+2' localhost/test
</geshi>
will yield the output
<geshi lang="bash">
    a b: 1a 2
</geshi>
Arguments without the <code>=<value></code> parts are treated as boolean arguments. For example, <code>GET /test?foo&bar</code> will yield the outputs
<geshi lang="bash">
    foo: true
    bar: true
</geshi>
That is, they will take Lua boolean values <code>true</code>. However, they're different from arguments taking empty string values. For example, <code>POST /test</code> with request body <code>foo=&bar=</code> will give something like
<geshi lang="bash">
    foo: 
    bar: 
</geshi>
Empty key arguments are discarded, for instance, <code>POST /test</code> with body <code>=hello&=world</code> will yield empty outputs.

== ngx.req.get_headers ==
'''syntax:''' ''headers = ngx.req.get_headers()''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Returns a Lua table holds all of the current request's request headers.

Here's an example,
<geshi lang="lua">
    local h = ngx.req.get_headers()
    for k, v in pairs(h) do
        ...
    end
</geshi>
To read an individual header:
<geshi lang="lua">
    ngx.say("Host: ", ngx.req.get_headers()["Host"])
</geshi>
For multiple instances of request headers like
<geshi lang="bash">
    Foo: foo
    Foo: bar
    Foo: baz
</geshi>
the value of <code>ngx.req.get_headers()["Foo"]</code> will be a Lua (array) table like this:
<geshi lang="lua">
    {"foo", "bar", "baz"}
</geshi>
Another way to read individual request headers is to use <code>ngx.var.http_HEADER</code>, that is, nginx's standard [[HttpCoreModule#$http_HEADER|$http_HEADER]] variables.

== ngx.req.set_header ==
'''syntax:''' ''ngx.req.set_header(header_name, header_value)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Set the current request's request header named <code>header_name</code> to value <code>header_value</code>, overriding any existing ones.
None of the current request's subrequests will be affected.

Here's an example of setting the <code>Content-Length</code> header:
<geshi lang="lua">
    ngx.req.set_header("Content-Type", "text/css")
</geshi>
The <code>header_value</code> can take an array list of values,
for example,
<geshi lang="lua">
    ngx.req.set_header("Foo", {"a", "abc"})
</geshi>
will produce two new request headers:
<geshi lang="bash">
    Foo: a
    Foo: abc
</geshi>
and old <code>Foo</code> headers will be overridden if there's any.

When the <code>header_value</code> argument is <code>nil</code>, the request header will be removed. So
<geshi lang="lua">
    ngx.req.set_header("X-Foo", nil)
</geshi>
is equivalent to
<geshi lang="lua">
    ngx.req.clear_header("X-Foo")
</geshi>

== ngx.req.clear_header ==
'''syntax:''' ''ngx.req.clear_header(header_name)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Clear the current request's request header named <code>header_name</code>. None of the current request's subrequests will be affected.

== ngx.exec ==
'''syntax:''' ''ngx.exec(uri, args?)''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Does an internal redirect to <code>uri</code> with <code>args</code>.

<geshi lang="lua">
    ngx.exec('/some-location');
    ngx.exec('/some-location', 'a=3&b=5&c=6');
    ngx.exec('/some-location?a=3&b=5', 'c=6');
</geshi>

Named locations are also supported, but query strings are ignored. For example,

<geshi lang="nginx">
    location /foo {
        content_by_lua '
            ngx.exec("@bar");
        ';
    }
 
    location @bar {
        ...
    }
</geshi>

The optional second <code>args</code> can be used to specify extra URI query arguments, for example:

<geshi lang="lua">
    ngx.exec("/foo", "a=3&b=hello%20world")
</geshi>

Alternatively, you can pass a Lua table for the <code>args</code> argument and let ngx_lua do URI escaping and string concatenation automatically for you, for instance,

<geshi lang="lua">
    ngx.exec("/foo", { a = 3, b = "hello world" })
</geshi>

The result is exactly the same as the previous example.

Note that this is very different from [[#ngx.redirect|ngx.redirect]] in that
it's just an internal redirect and no new HTTP traffic is involved.

This method never returns.

This method ''must'' be called before [[#ngx.send_headers|ngx.send_headers]] or explicit response body
outputs by either [[#ngx.print|ngx.print]] or [[#ngx.say|ngx.say]].

This method is very much like the [[HttpEchoModule#echo_exec|echo_exec]] directive in [[HttpEchoModule]].

== ngx.redirect ==
'''syntax:''' ''ngx.redirect(uri, status?)''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Issue an <code>HTTP 301<code> or <code>302</code> redirection to <code>uri</code>.

The optional <code>status</code> parameter specifies whether
<code>301</code> or <code>302</code> to be used. It's <code>302</code> (<code>ngx.HTTP_MOVED_TEMPORARILY</code>) by default.

Here's a small example:

<geshi lang="lua">
    return ngx.redirect("/foo")
</geshi>

which is equivalent to

<geshi lang="lua">
    return ngx.redirect("http://localhost:1984/foo", ngx.HTTP_MOVED_TEMPORARILY)
</geshi>

assuming the current server name is <code>localhost</code> and it's listening on the <code>1984</code> port.

This method ''must'' be called before [[#ngx.send_headers|ngx.send_headers]] or explicit response body outputs by either [[#ngx.print|ngx.print]] or [[#ngx.say|ngx.say]].

This method never returns.

This method is very much like the [[HttpRewriteModule#rewrite|rewrite]] directive with the <code>redirect</code> modifier in the standard
[[HttpRewriteModule]], for example, this <code>nginx.conf</code> snippet

<geshi lang="nginx">
    rewrite ^ /foo redirect;  # nginx config
</geshi>

is equivalent to the following Lua code

<geshi lang="lua">
    return ngx.redirect('/foo');  -- lua code
</geshi>

while

<geshi lang="nginx">
    rewrite ^ /foo permanent;  # nginx config
</geshi>

is equivalent to

<geshi lang="lua">
    return ngx.redirect('/foo', ngx.HTTP_MOVED_PERMANENTLY)  -- Lua code
</geshi>

== ngx.send_headers ==
'''syntax:''' ''ngx.send_headers()''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Explicitly send out the response headers.

Usually you don't have to send headers yourself. <code>ngx_lua</code> will automatically send out headers right before you
output contents via [[#ngx.say|ngx.say]] or [[#ngx.print|ngx.print]].

Headers will also be sent automatically when [[#content_by_lua|content_by_lua]] exits normally.

== ngx.headers_sent ==
'''syntax:''' ''value = ngx.headers_sent''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Returns <code>true</code> if the response headers have been sent (by ngx_lua), and <code>false</code> otherwise.

This API was first introduced in ngx_lua v0.3.1rc6.

== ngx.print ==
'''syntax:''' ''ngx.print(...)''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Emit arguments concatenated to the HTTP client (as response body). If response headers have not been sent yet, this function will first send the headers out, and then output the body data.

Lua <code>nil</code> value will result in outputing <code>"nil"</code>, and Lua boolean values will emit literal <code>"true"</code> or <code>"false"</code>, accordingly.

Also, nested arrays of strings are also allowed. The elements in the arrays will be sent one by one. For example

<geshi lang="lua">
    local table = {
        "hello, ",
        {"world: ", true, " or ", false,
            {": ", nil}}
    }
    ngx.print(table)
</geshi>

will yield the output

<geshi lang="bash">
    hello, world: true or false: nil
</geshi>

Non-array table arguments will cause a Lua exception to be thrown.

== ngx.say ==
'''syntax:''' ''ngx.say(...)''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Just as [[#ngx.print|ngx.print]] but also emit a trailing newline.

== ngx.log ==
'''syntax:''' ''ngx.log(log_level, ...)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Log arguments concatenated to error.log with the given logging level.

Lua <code>nil</code> arguments are accepted and result in literal <code>"nil"</code>, and Lua booleans result in literal <code>"true"</code> or <code>"false"</code> outputs.

The <code>log_level</code> argument can take constants like <code>ngx.ERR</code> and <code>ngx.WARN</code>. Check out [[#Nginx log level constants|Nginx log level constants]] for details.

== ngx.flush ==
'''syntax:''' ''ngx.flush()''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Force flushing the response outputs. This operation has no effect in HTTP 1.0 buffering output mode. See [[#HTTP 1.0 support|HTTP 1.0 support]].

== ngx.exit ==
'''syntax:''' ''ngx.exit(status)''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

When <code>status >= 200</code> (i.e., <code>ngx.HTTP_OK</code> and above), it will interrupt the execution of the current request and return status code to nginx.

When <code>status == 0</code> (i.e., <code>ngx.OK</code>), it will only quit the current phase handler (or the content handler if the [[#content_by_lua|content_by_lua]] directive is used) and continue to run laster phases (if any) for the current request.

The <code>status</code> argument can be <code>ngx.OK</code>, <code>ngx.ERROR</code>, <code>ngx.HTTP_NOT_FOUND</code>,
<code>ngx.HTTP_MOVED_TEMPORARILY</code>, or other [[#HTTP status constants|HTTP status constants]].

To return an error page with custom contents, use code snippets like this:

<geshi lang="lua">
    ngx.status = ngx.HTTP_GONE
    ngx.say("This is our own content")
    -- to cause quit the whole request rather than the current phase handler
    ngx.exit(ngx.HTTP_OK)
</geshi>

The effect in action:

<geshi lang="bash">
    $ curl -i http://localhost/test
    HTTP/1.1 410 Gone
    Server: nginx/1.0.6
    Date: Thu, 15 Sep 2011 00:51:48 GMT
    Content-Type: text/plain
    Transfer-Encoding: chunked
    Connection: keep-alive

    This is our own content
</geshi>

== ngx.eof ==
'''syntax:''' ''ngx.eof()''

'''context:''' ''rewrite_by_lua*, access_by_lua*, content_by_lua*''

Explicitly specify the end of the response output stream.

== ngx.escape_uri ==
'''syntax:''' ''newstr = ngx.escape_uri(str)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Escape <code>str</code> as a URI component.

== ngx.unescape_uri ==
'''syntax:''' ''newstr = ngx.unescape_uri(str)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Unescape <code>str</code> as an escaped URI component.

== ngx.encode_base64 ==
'''syntax:''' ''newstr = ngx.encode_base64(str)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Encode <code>str</code> to a base64 digest.

== ngx.decode_base64 ==
'''syntax:''' ''newstr = ngx.decode_base64(str)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Decodes the <code>str</code> argument as a base64 digest to the raw form. Returns <code>nil</code> if <code>str</code> is not well formed.

== ngx.crc32_short ==
'''syntax:''' ''intval = ngx.crc32_short(str)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Calculates the CRC-32 (Cyclic Redundancy Code) digest for the <code>str</code> argument.

This method performs better on relatively short <code>str</code> inputs (i.e., less than 30 ~ 60 bytes), as compared to [[#ngx.crc32_long|ngx.crc32_long]]. The result is exactly the same as [[#ngx.crc32_long|ngx.crc32_long]].

Behind the scene, it is just a thin wrapper around the <code>ngx_crc32_short</code> function defined in the Nginx core.

This API was first introduced in the <code>v0.3.1rc8</code> release.

== ngx.crc32_long ==
'''syntax:''' ''intval = ngx.crc32_long(str)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Calculates the CRC-32 (Cyclic Redundancy Code) digest for the <code>str</code> argument.

This method performs better on relatively long <code>str</code> inputs (i.e., longer than 30 ~ 60 bytes), as compared to [[#ngx.crc32_short|ngx.crc32_short]].  The result is exactly the same as [[#ngx.crc32_short|ngx.crc32_short]].

Behind the scene, it is just a thin wrapper around the <code>ngx_crc32_long</code> function defined in the Nginx core.

This API was first introduced in the <code>v0.3.1rc8</code> release.

== ngx.today ==
'''syntax:''' ''str = ngx.today()''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Returns today's date (in the format <code>yyyy-mm-dd</code>) from nginx cached time (no syscall involved unlike Lua's date library).

This is the local time.

== ngx.time ==
'''syntax:''' ''secs = ngx.time()''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Returns the elapsed seconds from the epoch for the current timestamp from the nginx cached time (no syscall involved unlike Lua's date library).

== ngx.localtime ==
'''syntax:''' ''str = ngx.localtime()''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Returns the current timestamp (in the format <code>yyyy-mm-dd hh:mm:ss</code>) of the nginx cached time (no syscall involved unlike Lua's [http://www.lua.org/manual/5.1/manual.html#pdf-os.date os.date] function).

This is the local time.

== ngx.utctime ==
'''syntax:''' ''str = ngx.utctime()''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Returns the current timestamp (in the format <code>yyyy-mm-dd hh:mm:ss</code>) of the nginx cached time (no syscall involved unlike Lua's [http://www.lua.org/manual/5.1/manual.html#pdf-os.date os.date] function).

This is the UTC time.

== ngx.cookie_time ==
'''syntax:''' ''str = ngx.cookie_time(sec)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Returns a formated string can be used as the cookie expiration time. The parameter <code>sec</code> is the timestamp in seconds (like those returned from [[#ngx.time|ngx.time]]).
<geshi lang="nginx">
    ngx.say(ngx.cookie_time(1290079655))
        -- yields "Thu, 18-Nov-10 11:27:35 GMT"
</geshi>
== ngx.http_time ==
'''syntax:''' ''str = ngx.http_time(sec)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Returns a formated string can be used as the http header time (for example, being used in <code>Last-Modified</code> header). The parameter <code>sec</code> is the timestamp in seconds (like those returned from [[#ngx.time|ngx.time]]).
<geshi lang="nginx">
    ngx.say(ngx.http_time(1290079655))
        -- yields "Thu, 18 Nov 10 11:27:35 GMT"
</geshi>
== ngx.parse_http_time ==
'''syntax:''' ''sec = ngx.parse_http_time(str)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Parse the http time string (as returned by [[#ngx.http_time|ngx.http_time]]) into seconds. Returns the seconds or <code>nil</code> if the input string is in bad forms.
<geshi lang="nginx">
    local time = ngx.parse_http_time("Thu, 18 Nov 10 11:27:35 GMT")
    if time == nil then
        ...
    end
</geshi>
== ngx.is_subrequest ==
'''syntax:''' ''value = ngx.is_subrequest''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Returns <code>true</code> if the current request is an nginx subrequest, or <code>false</code> otherwise.

== ngx.re.match ==
'''syntax:''' ''captures = ngx.re.match(subject, regex, options?, ctx?)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Matches the <code>subject</code> string using the Perl-compatible regular expression <code>regex</code> with the optional <code>options</code>.

Only the first occurrence of the match is returned, or <code>nil</code> if no match is found. In case of fatal errors, like seeing bad <code>UTF-8</code> sequences in <code>UTF-8</code> mode, a Lua exception will be raised.

When a match is found, a Lua table <code>captures</code> is returned, where <code>captures[0]</code> holds the whole substring being matched, and <code>captures[1]</code> holds the first parenthesized subpattern's capturing, <code>captures[2]</code> the second, and so on. Here's some examples:

<geshi lang="lua">
    local m = ngx.re.match("hello, 1234", "[0-9]+")
    -- m[0] == "1234"
</geshi>

<geshi lang="lua">
    local m = ngx.re.match("hello, 1234", "([0-9])[0-9]+")
    -- m[0] == "1234"
    -- m[1] == "1"
</geshi>

Unmatched subpatterns will take <code>nil</code> values in their <code>captures</code> table fields. For instance,

<geshi lang="lua">
    local m = ngx.re.match("hello, world", "(world)|(hello)")
    -- m[0] == "hello"
    -- m[1] == nil
    -- m[2] == "hello"
</geshi>

Escaping sequences in Perl-compatible regular expressions like <code>\d</code>, <code>\s</code>, and <code>\w</code>, require special care when specifying them in Lua string literals, because the backslash character, <code>\</code>, needs to be escaped in Lua string literals too, for example,

<geshi lang="lua">
    ? m = ngx.re.match("hello, 1234", "\d+")
</geshi>

won't work as expected and won't match at all. Intead, you should escape the backslash itself and write

<geshi lang="lua">
    m = ngx.re.match("hello, 1234", "\\d+")
</geshi>

When you put the Lua code snippet in your <code>nginx.conf</code> file, you have to escape the backslash one more time, because your Lua code is now in an nginx string literal, and backslashes in nginx string literals require escaping as well. For instance,

<geshi lang="nginx">
    location /test {
        content_by_lua '
            local m = ngx.re.match("hello, 1234", "\\\\d+")
            if m then ngx.say(m[0]) else ngx.say("not matched!") end
        ';
    }
</geshi>

You can also specify <code>options</code> to control how the match will be performed. The following option characters are supported:

<geshi lang="text">
    a             anchored mode (only match from the beginning)
    i             caseless mode (just like Perl's /i modifier)
    m             multi-line mode (just like Perl's /m modifier)
    o             compile-once mode (similar to Perl's /o modifer),
                  to enable the worker-process-level compiled-regex cache
    s             single-line mode (just like Perl's /s modifier)
    u             UTF-8 mode
    x             extended mode (just like Perl's /x modifier)
</geshi>

These characters can be combined together, for example,

<geshi lang="nginx">
    local m = ngx.re.match("hello, world", "HEL LO", "ix")
    -- m[0] == "hello"
</geshi>

<geshi lang="nginx">
    local m = ngx.re.match("hello, 美好生活", "HELLO, (.{2})", "iu")
    -- m[0] == "hello, 美好"
    -- m[1] == "美好"
</geshi>

The <code>o</code> regex option is good for performance tuning, because the regex in question will only be compiled once, cached in the worker-process level, and shared among all the requests in the current Nginx worker process. You can tune the upper limit of the regex cache via the [[#lua_regex_cache_max_entries|lua_regex_cache_max_entries]] directive.

The optional fourth argument, <code>ctx</code>, can be a Lua table holding an optional <code>pos</code> field. When the <code>pos</code> field in the <code>ctx</code> table argument is specified, <code>ngx.re.match</code> will start matching from that offset. Regardless of the presence of the <code>pos</code> field in the <code>ctx</code> table, <code>ngx.re.match</code> will always set this <code>pos</code> field to the position ''after'' the substring matched by the whole pattern in case of a successful match. When match fails, the <code>ctx</code> table will leave intact. Here is some examples,

<geshi lang="lua">
    local ctx = {}
    local m = ngx.re.match("1234, hello", "[0-9]+", "", ctx)
         -- m[0] = "1234"
         -- ctx.pos == 4
</geshi>

<geshi lang="lua">
    local ctx = { pos = 2 }
    local m = ngx.re.match("1234, hello", "[0-9]+", "", ctx)
         -- m[0] = "34"
         -- ctx.pos == 4
</geshi>

The <code>ctx</code> table argument combined with the <code>a</code> regex modifier can be used to construct a lexer atop <code>ngx.re.match</code>.

Note that, the <code>options</code> argument is not optional when the <code>ctx</code> argument is specified; use the empty Lua string (<code>""</code>) as the placeholder for <code>options</code> if you do not want to specify any regex options.

This method requires the PCRE library enabled in your Nginx build.

This feature is introduced in the <code>v0.2.1rc11</code> release.

== ngx.re.gmatch ==
'''syntax:''' ''iterator = ngx.re.gmatch(subject, regex, options?)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Similar to [[#ngx.re.match|ngx.re.match]], but returns a Lua iterator instead, so as to let the user programmer iterate all the matches over the <code><subject></code> string argument with the Perl-compatible regular expression <code>regex</code>.

Here's a small exmple to demonstrate its basic usage:

<geshi lang="lua">
    local iterator = ngx.re.gmatch("hello, world!", "([a-z]+)", "i")
    local m
    m = iterator()    -- m[0] == m[1] == "hello"
    m = iterator()    -- m[0] == m[1] == "world"
    m = iterator()    -- m == nil
</geshi>

More often we just put it into a Lua <code>for</code> loop:

<geshi lang="lua">
    for m in ngx.re.gmatch("hello, world!", "([a-z]+)", "i")
        ngx.say(m[0])
        ngx.say(m[1])
    end
</geshi>

The optional <code>options</code> argument takes exactly the same semantics as the [[#ngx.re.match|ngx.re.match]] method.

The current implementation requires that the iterator returned should only be used in a single request. That is, one should ''not'' assign it to a variable belonging to persistent namespace like a Lua package.

This method requires the PCRE library enabled in your Nginx build.

This feature was first introduced in the <code>v0.2.1rc12</code> release.

== ngx.re.sub ==
'''syntax:''' ''newstr, n = ngx.re.sub(subject, regex, replace, options?)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Substitutes the first match of the Perl-compatible regular expression <code>regex</code> on the <code>subject</code> argument string with the string or function argument <code>replace</code>. The optional <code>options</code> argument has exactly the same meaning as in [[#ngx.re.match|ngx.re.match]].

This method returns the resulting new string as well as the number of successful substitutions, or throw out a Lua exception when an error occurred (syntax errors in the <code><replace></code> string argument, for example).

When the <code>replace</code> is a string, then it is treated as a special template for string replacement. For example,

<geshi lang="lua">
    local newstr, n = ngx.re.sub("hello, 1234", "([0-9])[0-9]", "[$0][$1]")
        -- newstr == "hello, [12][1]34"
        -- n == 1
</geshi>

where <code>$0</code> referring to the whole substring matched by the pattern and <code>$1</code> referring to the first parenthesized capturing substring.

You can also use curly braces to disambiguate variable names from the background string literals: 

<geshi lang="lua">
    local newstr, n = ngx.re.sub("hello, 1234", "[0-9]", "${0}00")
        -- newstr == "hello, 10034"
        -- n == 1
</geshi>

Literal dollar sign characters (<code>$</code>) in the <code>replace</code> string argument can be escaped by another dollar sign, for instance,

<geshi lang="lua">
    local newstr, n = ngx.re.sub("hello, 1234", "[0-9]", "$$")
        -- newstr == "hello, $234"
        -- n == 1
</geshi>

Do not use backlashes to escape dollar signs; it won't work as expected.

When the <code>replace</code> argument is of type "function", then it will be invoked with the "match table" as the argument to generate the replace string literal for substitution. The "match table" fed into the <code>replace</code> function is exactly the same as the return value of [[#ngx.re.match|ngx.re.match]]. Here is an example:

<geshi lang="lua">
    local func = function (m)
        return "[" .. m[0] .. "][" .. m[1] .. "]"
    end
    local newstr, n = ngx.re.sub("hello, 1234", "( [0-9] ) [0-9]", func, "x")
        -- newstr == "hello, [12][1]34"
        -- n == 1
</geshi>

The dollar sign characters in the return value of the <code>replace</code> function argument are not special at all.

This method requires the PCRE library enabled in your Nginx build.

This feature was first introduced in the <code>v0.2.1rc13</code> release.

== ngx.re.gsub ==
'''syntax:''' ''newstr, n = ngx.re.gsub(subject, regex, replace, options?)''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

Just like [[#ngx.re.sub|ngx.re.sub]], but does global substitution.

Here is some examples:

<geshi lang="lua">
    local newstr, n = ngx.re.gsub("hello, world", "([a-z])[a-z]+", "[$0,$1]", "i")
        -- newstr == "[hello,h], [world,w]"
        -- n == 2
</geshi>

<geshi lang="lua">
    local func = function (m)
        return "[" .. m[0] .. "," .. m[1] .. "]"
    end
    local newstr, n = ngx.re.gsub("hello, world", "([a-z])[a-z]+", func, "i")
        -- newstr == "[hello,h], [world,w]"
        -- n == 2
</geshi>

This method requires the PCRE library enabled in your Nginx build.

This feature was first introduced in the <code>v0.2.1rc15</code> release.

== ndk.set_var.DIRECTIVE ==
'''syntax:''' ''res = ndk.set_var.DIRECTIVE_NAME''

'''context:''' ''set_by_lua*, rewrite_by_lua*, access_by_lua*, content_by_lua*, header_filter_by_lua*''

This mechanism allows calling other nginx C modules' directives that are implemented by [https://github.com/simpl/ngx_devel_kit Nginx Devel Kit] (NDK)'s set_var submodule's <code>ndk_set_var_value</code>.

For example, [[HttpSetMiscModule]]'s following directives can be invoked this way:

* [[HttpSetMiscModule#set_quote_sql_str|set_quote_sql_str]]
* [[HttpSetMiscModule#set_quote_pgsql_str|set_quote_pgsql_str]]
* [[HttpSetMiscModule#set_quote_json_str|set_quote_json_str]]
* [[HttpSetMiscModule#set_unescape_uri|set_unescape_uri]]
* [[HttpSetMiscModule#set_escape_uri|set_escape_uri]]
* [[HttpSetMiscModule#set_encode_base32|set_encode_base32]]
* [[HttpSetMiscModule#set_decode_base32|set_decode_base32]]
* [[HttpSetMiscModule#set_encode_base64|set_encode_base64]]
* [[HttpSetMiscModule#set_decode_base64|set_decode_base64]]
* [[HttpSetMiscModule#set_encode_base64|set_encode_hex]]
* [[HttpSetMiscModule#set_decode_base64|set_decode_hex]]
* [[HttpSetMiscModule#set_encode_base64|set_sha1]]
* [[HttpSetMiscModule#set_decode_base64|set_md5]]

For instance,

<geshi lang="lua">
    local res = ndk.set_var.set_escape_uri('a/b');
    -- now res == 'a%2fb'
</geshi>

Similarly, the following directives provided by [[HttpEncryptedSessionModule]] can be invoked from within Lua too:

* [[HttpEncryptedSessionModule#set_encrypt_session|set_encrypt_session]]
* [[HttpEncryptedSessionModule#set_decrypt_session|set_decrypt_session]]

This feature requires the [https://github.com/simpl/ngx_devel_kit ngx_devel_kit] module.

= HTTP 1.0 support =

The HTTP 1.0 protocol does not support chunked outputs and always requires an
explicit <code>Content-Length</code> header when the response body is non-empty. So when
an HTTP 1.0 request is present, This module will automatically buffer all the
outputs of user calls of [[#ngx.say|ngx.say]] and [[#ngx.print|ngx.print]] and
postpone sending response headers until it sees all the outputs in the response
body, and at that time ngx_lua can calculate the total length of the body and
construct a proper <code>Content-Length</code> header for the HTTP 1.0 client.

Note that, common HTTP benchmark tools like <code>ab</code> and <code>http_load</code> always issue
HTTP 1.0 requests by default. To force <code>curl</code> to send HTTP 1.0 requests, use
the <code>-0</code> option.

= Data Sharing within an Nginx Worker =

'''NOTE: This mechanism behaves differently when code cache is turned off, and should be considered as a DIRTY TRICK. Backward compatibility is NOT guaranteed. Use at your own risk! We're going to design a whole new data-sharing mechanism.'''

If you want to globally share user data among all the requests handled by the same nginx worker process, you can encapsulate your shared data into a Lua module, require the module in your code, and manipulate shared data through it. It works because required Lua modules are loaded only once, and all coroutines will share the same copy of the module.

Here's a complete small example:

<geshi lang="lua">
    -- mydata.lua
    module("mydata", package.seeall)
 
    local data = {
        dog = 3,
        cat = 4,
        pig = 5,
    }
 
    function get_age(name)
        return data[name]
    end
</geshi>

and then accessing it from your nginx.conf:

<geshi lang="nginx">
    location /lua {
        content_lua_by_lua '
            local mydata = require("mydata")
            ngx.say(mydata.get_age("dog"))
        ';
    }
</geshi>

Your <code>mydata</code> module in this example will only be loaded
and run on the first request to the location <code>/lua</code>,
and all those subsequent requests to the same nginx
worker process will use the reloaded instance of the
module as well as the same copy of the data in it,
until you send a <code>HUP</code> signal to the nginx master
process to enforce a reload.

This data sharing technique is essential for high-performance Lua apps built atop this module. It's common to cache reusable data globally.

It's worth noting that this is ''per-worker'' sharing, not ''per-server'' sharing. That is, when you have multiple nginx worker processes under an nginx master, this data sharing cannot pass process boundary. If you indeed need server-wide data sharing, you can

# Use only a single nginx worker and a single server. This is not recommended when you have a multi-core CPU or multiple CPUs in a single machine.
# Use some true backend storage like <code>memcached</code>, <code>redis</code>, or an RDBMS like <code>mysql</code>.

= Performance =

The Lua state (aka the Lua vm instance) is shared across all the requests
handled by a single nginx worker process to miminize memory use.

On a ThinkPad T400 2.80 GHz laptop, it's easy to achieve 25k req/sec using ab
w/o keepalive and 37k+ req/sec with keepalive.

You can get better performance when building this module
with LuaJIT 2.0.

= Installation =

You're recommended to install this module as well as the Lua interpreter or LuaJIT 2.0 (with many other good stuffs) via the ngx_openresty bundle:

http://openresty.org 

The installation steps are usually as simple as <code>./configure && make && make install</code>.

Alternatively, you can compile this module with nginx core's source by hand:

# Install Lua or LuaJIT into your system. At least Lua 5.1 is required.  Lua can be obtained freely from its project [http://www.lua.org/ homepage].  For Ubuntu/Debian users, just install the liblua5.1-0-dev package (or something like that).
# Download the latest version of the release tarball of the ngx_devel_kit (NDK) module from lua-nginx-module [http://github.com/simpl/ngx_devel_kit/downloads file list].
# Download the latest version of the release tarball of this module from lua-nginx-module [http://github.com/chaoslawful/lua-nginx-module/downloads file list].
# Grab the nginx source code from [http://nginx.org/ nginx.org], for example, the version 1.0.5 (see nginx compatibility), and then build the source with this module:
<geshi lang="bash">
        $ wget 'http://nginx.org/download/nginx-1.0.5.tar.gz'
        $ tar -xzvf nginx-1.0.5.tar.gz
        $ cd nginx-1.0.5/
 
        # tell nginx's build system where to find lua:
        export LUA_LIB=/path/to/lua/lib
        export LUA_INC=/path/to/lua/include
 
        # or tell where to find LuaJIT when you want to use JIT instead
        # export LUAJIT_LIB=/path/to/luajit/lib
        # export LUAJIT_INC=/path/to/luajit/include/luajit-2.0
 
        # Here we assume you would install you nginx under /opt/nginx/.
        $ ./configure --prefix=/opt/nginx \
            --add-module=/path/to/ngx_devel_kit \
            --add-module=/path/to/lua-nginx-module
 
        $ make -j2
        $ make install
</geshi>

= Compatibility =

The following versions of Nginx should work with this module:

*   1.0.x (last tested: 1.0.6)
*   0.9.x (last tested: 0.9.4)
*   0.8.x >= 0.8.54 (last tested: 0.8.54)

Earlier versions of Nginx like 0.6.x and 0.5.x will '''not''' work.

If you find that any particular version of Nginx above 0.8.54 does not
work with this module, please consider reporting a bug.

= Report Bugs =

Although a lot of effort has been put into testing and code tuning, there must be some serious bugs lurking somewhere in this module. So whenever you are bitten by any quirks, please don't hesitate to

# create a ticket on the [http://github.com/chaoslawful/lua-nginx-module/issues issue tracking interface] provided by GitHub,
# or send a bug report or even patches to the [http://mailman.nginx.org/mailman/listinfo/nginx nginx mailing list].

= Source Repository =

Available on github at [http://github.com/chaoslawful/lua-nginx-module chaoslawful/lua-nginx-module].

= Test Suite =

To run the test suite, you also need the following dependencies:

* Nginx version >= 0.8.54

* Perl modules:
** test-nginx: http://github.com/agentzh/test-nginx 

* Nginx modules:
** echo-nginx-module: http://github.com/agentzh/echo-nginx-module 
** drizzle-nginx-module: http://github.com/chaoslawful/drizzle-nginx-module 
** rds-json-nginx-module: http://github.com/agentzh/rds-json-nginx-module 
** set-misc-nginx-module: http://github.com/agentzh/set-misc-nginx-module 
** headers-more-nginx-module: http://github.com/agentzh/headers-more-nginx-module 
** memc-nginx-module: http://github.com/agentzh/memc-nginx-module 
** srcache-nginx-module: http://github.com/agentzh/srcache-nginx-module 
** ngx_auth_request: http://mdounin.ru/hg/ngx_http_auth_request_module/ 

* C libraries:
** yajl: https://github.com/lloyd/yajl 

* Lua modules:
** lua-yajl: https://github.com/brimworks/lua-yajl 
*** Note: the compiled module has to be placed in '/usr/local/lib/lua/5.1/'

* Applications:
** mysql: create database 'ngx_test', grant all privileges to user 'ngx_test', password is 'ngx_test'
** memcached

These module's adding order is IMPORTANT! For filter modules's position in
filtering chain affects a lot. The correct configure adding order is:

# ngx_devel_kit
# set-misc-nginx-module
# ngx_http_auth_request_module
# echo-nginx-module
# memc-nginx-module
# lua-nginx-module (i.e. this module)
# headers-more-nginx-module
# srcache-nginx-module
# drizzle-nginx-module
# rds-json-nginx-module

= TODO =

* Add <code>ignore_resp_headers</code>, <code>ignore_resp_body</code>, and <code>ignore_resp</code> options to [[#ngx.location.capture|ngx.location.capture]] and ngx.location.capture_multi` methods, to allow micro performance tuning on the user side.
* Add directives to run lua codes when nginx stops/reloads.
* Deal with TCP 3-second delay problem under great connection harness.

= Future Plan =

* Add the <code>lua_require</code> directive to load module into main thread's globals.
* Add the "cosocket" mechamism that will emulate a common set of Lua socket API that will give you totally transparently non-blocking capability out of the box by means of a completely new upstream layer atop the nginx event model and no nginx subrequest overheads.
* Add Lua code automatic time slicing support by yielding and resuming the Lua VM actively via Lua's debug hooks.
* Make set_by_lua using the same mechanism as content_by_lua.

= Known Issues =

* As ngx_lua's predefined Nginx I/O APIs use coroutine yielding/resuming mechanism, the user code should not call any Lua modules that use coroutine API to prevent obfuscating the predefined Nginx APIs like [[#ngx.location.capture|ngx.location.capture]] (actually coroutine modules have been masked off in [[#content_by_lua|content_by_lua]] directives and others). This limitation is a little crucial, but don't worry, we're working on an alternative coroutine implementation that can fit into the Nginx event model. When it is done, the user code will be able to use the Lua coroutine mechanism freely as in standard Lua again!
* Because the standard Lua 5.1 interpreter's VM is not fully resumable, the methods [[#ngx.location.capture|ngx.location.capture]], [[#ngx.location.capture_multi|ngx.location.capture_multi], [[#ngx.redirect|ngx.redirect]], [[#ngx.exec|ngx.exec]], and [[#ngx.exit|ngx.exit]] cannot be used within the context of a Lua [http://www.lua.org/manual/5.1/manual.html#pdf-pcall pcall()] or [http://www.lua.org/manual/5.1/manual.html#pdf-xpcall xpcall()] when the standard Lua 5.1 interpreter is used; you'll get the error <code>attempt to yield across metamethod/C-call boundary</code>. To fix this, please use LuaJIT 2.0 instead, because LuaJIT 2.0 supports a fully resume-able VM.
* The [[#ngx.location.capture|ngx.location.capture]] and [[#ngx.location.capture_multi|ngx.location.capture_multi]] Lua methods cannot capture locations configured by [[HttpEchoModule]]'s [[HttpEchoModule#echo_location|echo_location]], [[HttpEchoModule#echo_location_async|echo_location_async]], [[HttpEchoModule#echo_subrequest|echo_subrequest]], or [[HttpEchoModule#echo_subrequest_async|echo_subrequest_async]] directives. This won't be fixed in the future due to technical problems.
* '''WATCH OUT: Globals WON'T persist between requests''', because of the one-coroutine-per-request isolation design. Especially watch yourself when using <code>require()</code> to import modules, and use this form:
<geshi lang="nginx">
        local xxx = require('xxx')
</geshi>
: instead of the old deprecated form:
<geshi lang="nginx">
        require('xxx')
</geshi>
: The old form will cause module unusable in requests for the reason told previously. If you have to stick with the old form, you can always force loading module for every request by clean <code>package.loaded.<module></code>, like this:
<geshi lang="nginx">
        package.loaded.xxx = nil
        require('xxx')
</geshi>
* It's recommended to always put the following piece of code at the end of your Lua modules using [[#ngx.location.capture|ngx.location.capture]] or [[#ngx.location.capture_multi|ngx.location.capture_multi]] to prevent casual use of module-level global variables that are shared among ''all'' requests, which is usually not what you want:
<geshi lang="nginx">
    getmetatable(foo.bar).__newindex = function (table, key, val)
        error('Attempt to write to undeclared variable "' .. key .. '": '
                .. debug.traceback())
    end
</geshi>
assuming your current Lua module is named <code>foo.bar</code>. This will guarantee that you have declared your Lua functions' local Lua variables as "local" in your Lua modules, or bad race conditions while accessing these variables under load will tragically happen. See the <code>Data Sharing within an Nginx Worker</code> for the reasons of this danger.

= Changes =

== v0.3.0 ==
'''New features'''

* added the [[#header_filter_by_lua|header_filter_by_lua]] and [[#header_filter_by_lua_file|header_filter_by_lua_file]] directives. thanks Liseen Wan (万珣新).
* implemented the PCRE regex API for Lua: [[#ngx.re.match|ngx.re.match]], [[#ngx.re.gmatch|ngx.re.gmatch]], [[#ngx.re.sub|ngx.re.sub]], and [[#ngx.re.gsub|ngx.re.gsub]].
* now we add the <code>ngx</code> and <code>ndk</code> table into <code>package.loaded</code> such that the user can write <code>local ngx = require 'ngx'</code> and <code>local ndk = require 'ndk'</code>. thanks @Lance.
* added new directive [[#lua_regex_cache_max_entries|lua_regex_cache_max_entries]] to control the upper limit of the worker-process-level compiled-regex cache enabled by the <code>o</code> regex option.
* implemented the special [[#ngx.ctx|ngx.ctx]] Lua table for user programmers to store per-request Lua context data for their applications. thanks 欧远宁 for suggesting this feature.
* now [[#ngx.print|ngx.print]] and [[#ngx.say|ngx.say]] allow (nested) array-like table arguments. the array elements in them will be sent piece by piece. this will avoid string concatenation for templating engines like [http://www.savarese.com/software/ltp/ ltp].
* implemented the [[#ngx.req.get_post_args|ngx.req.get_post_args]] method for fetching url-encoded POST query arguments from within Lua.
* implemented the [[#ngx.req.get_uri_args|ngx.req.get_uri_args]] method to fetch parsed URL query arguments from within Lua. thanks Bertrand Mansion (golgote).
* added new function [[#ngx.parse_http_time|ngx.parse_http_time]], thanks James Hurst.
* now we allow Lua boolean and <code>nil</code> values in arguments to [[#ngx.say|ngx.say]], [[#ngx.print|ngx.print]], [[#ngx.log|ngx.log]] and [[#print|print]].
* added support for user C macros <code>LUA_DEFAULT_PATH</code> and <code>LUA_DEFAULT_CPATH</code>. for now we can only define them in <code>ngx_lua</code>'s <code>config</code> file because nginx <code>configure</code>'s <code>--with-cc-opt</code> option hates values with double-quotes in them. sigh. [http://openresty.org/ ngx_openresty] is already using this feature to bundle 3rd-party Lua libraries.

'''Bug fixes'''

* worked-around the "stack overflow" issue while using <code>luarocks.loader</code> and disabling [[#lua_code_cache|lua_code_cache]], as described as github issue #27. thanks Patrick Crosby.
* fixed the <code>zero size buf in output</code> alert while combining [[#lua_need_request_body|lua_need_request_body]] on + [[#access_by_lua|access_by_lua]]/[[#rewrite_by_lua|rewrite_by_lua]] + [[HttpProxyModule#proxy_pass|proxy_pass]]/[[HttpFcgiModule#fastcgi_pass|fastcgi_pass]]. thanks Liseen Wan (万珣新).
* fixed issues with HTTP 1.0 HEAD requests.
* made setting <code>ngx.header.HEADER</code> after sending out response headers throw out a Lua exception to help debugging issues like github issue #49. thanks Bill Donahue (ikhoyo).
* fixed an issue regarding defining global variables in C header files: we should have defined the global <code>ngx_http_lua_exception</code> in a single compilation unit. thanks @姜大炮.

= Authors =

* chaoslawful (王晓哲) <chaoslawful at gmail dot com>
* Zhang "agentzh" Yichun (章亦春) <agentzh at gmail dot com>

= Copyright & License =

This module is licenced under the BSD license.

Copyright (C) 2009, 2010, 2011, Taobao Inc., Alibaba Group ( http://www.taobao.com ).

Copyright (C) 2009, 2010, 2011, by Xiaozhe Wang (chaoslawful) <chaoslawful@gmail.com>.

Copyright (C) 2009, 2010, 2011, by Zhang "agentzh" Yichun (章亦春) <agentzh@gmail.com>.

All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

= See Also =

* [http://openresty.org/#DynamicRoutingBasedOnRedis Dynamic Routing Based on Redis and Lua]
* [http://openresty.org/#UsingLuaRocks Using LuaRocks with ngx_lua]
* [https://github.com/chaoslawful/lua-nginx-module/wiki/Introduction Introduction to ngx_lua]
* [http://github.com/simpl/ngx_devel_kit ngx_devel_kit]
* [[HttpEchoModule]]
* [[HttpDrizzleModule]]
* [http://github.com/FRiCKLE/ngx_postgres postgres-nginx-module]
* [[HttpMemcModule]]
* [http://openresty.org The ngx_openresty bundle]

